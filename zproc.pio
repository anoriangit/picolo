.program zproc


; timing at 252MHz
; wait: 1 cycle = 3.968 ns
; in: 1 cycle = 3.968 ns
; push: 1 cycle = 3.968 ns
; wrap: 0 cycles
; Total per loop (without wait blocking): 3×3.968=11.904 ns3 \times 3.968 = 11.904 \, \text{ns}3 \times 3.968 = 11.904 \, \text{ns}
; If wait blocks, add the blocking time (in multiples of 3.968 ns based on how many cycles GP6 is low).


; This is used to process data to&from the Z80
    .wrap_target

    ; Wait for GP6 to go low (active)
    wait 1 pin 6      ; Wait until GP6 (pin 6) is high
    wait 0 pin 6      ; Wait until GP6 (pin 6) is low  
    ;nop         [3]    ; Wait 20 cycles
    
    ; Read GP0-GP5 states into ISR (Input Shift Register)
    in pins, 6        ; Read 6 pins (GP0-GP5) into ISR
    ; Push the read value to the RX FIFO
    push              ; Send the 6-bit value to the RX FIFO


    .wrap

% c-sdk {

// Helper function (for use in C program) to initialize this PIO program
void zproc_program_init(PIO pio, uint sm, uint offset) {

    // Sets up state machine and wrap target. This function is automatically
    // generated in zproc.pio.h.
    pio_sm_config c = zproc_program_get_default_config(offset);

    // Set pin base for input (GP0-GP6)
    sm_config_set_in_pins(&c, 0);       // Start at GP0
    sm_config_set_in_pin_count(&c, 7);  // GP0-GP6 (7 pins)

    // Set shift direction (right shift for ISR)
    sm_config_set_in_shift(&c, true, false, 32); // Right shift, no autopush

    // Initialize GP0-GP6 as PIO-controlled inputs
    for (uint i = 0; i <= 6; i++) {
        pio_gpio_init(pio, i);
        // gpio_set_pulls(i, false, true); // Enable pull-down, disable pull-up
    }

    // Set GP0-GP6 as inputs
    pio_sm_set_consecutive_pindirs(pio, sm, 0, 7, false);    // false = input
    
    // Load configuration and jump to start of the program
    pio_sm_init(pio, sm, offset, &c);
}

%}