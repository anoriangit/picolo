
; This program reads 12 pins (GP0-GP11) 
; GP0-GP7 are connected to the Z80 address lines A0-A7 (through a transceiver)
; GP11 = RD


; Transceiver Information
; SN74LVC245A used for 5V -> 3.3V down translation
; runs at VCC 3.3V
; Pin propagation time at VCC: max 8.3 ns
; OE Enable at VCC: 11 ns
; OE Disable at VCC: 9.5 ns

; TXS0108E
; OE Enable: 200 ns
; OE Disable: 400 ns


; timing at 252MHz
; wait: 1 cycle = 3.968 ns
; in: 1 cycle = 3.968 ns
; push: 1 cycle = 3.968 ns
; wrap: 0 cycles
; Total per loop (without wait blocking): 3Ã—3.968=11.904
; If wait blocks, add the blocking time (in multiples of 3.968 ns based on how many cycles GP6 is low).
; DMA: each transfer needs around 100 ns

.program zproc

.define public NUM_BUS_PINS    8    ; (0-7)
.define public NUM_PINS        11   ; (0-10)

.define public RD_PIN      8
.define public ADDR_OE_PIN 9     ; GP9 for address transceiver OE
.define public DATA_OE_PIN 10    ; GP10 for data transceiver OE

; This is used to process data to&from the Z80

    ; get the SRAM base address into x
    pull
    mov x, osr
   
    /* NOTE on "out"
     * this function writes 32bits to your pins, no matter how many bits 
     * you specify as argument. The argument only defines how many bits come from the OSR
     * the remainder is written as 0. In our case this means that pins 8-10, which
     * we carefully set up to be outputs, will be set to 0 to and thus redefined
     * as inputs by the "out"
     */
    mov osr, null
    out pindirs, NUM_BUS_PINS

    // switch OE control pins back to output (see note above)
    // note that GP8 (RD) has been set to "input" by the "out" above too
    set pindirs, 0b11 [2]   ; GP9, GP10 outputs (bits 0, 1)
    set pins, 0b00          ; ADDR_OE low (0) (active), DATA_OE low (0) (inactive)
    nop [25]                ; delay 26 cycles (26*3.968=103.168ns) for TXS0108E transition

    .wrap_target

    ; ------------------------------------
    ; Wait for GP6 to go low (active)
    wait 0 pin RD_PIN       ; Wait until GP6 (pin 6) is low  

    ; ------------------------------------
    ; Note that everything below absolutely MUST happen within the time
    ; that the Z80 needs before it will request  the next byte
    ; The minimum timespan is 4 Z80 cycles
    ; at 4MHz the Z80 needs 1usec (1000ns) for 4 cycles
    ; while the PIO (at 252MHz) requires 3.968 ns / operation
    ; ==> we can process ~ 252 pio operations during one Z80 cycle
    ; Problem: The TXS0108E needs extremely long for enable/disable
    ; as long as that is in use 200+400=600ns (60% of our budget) 
    ; are required for OE on that transceiver alone


    ; ------------------------------------
    ; Read GP0-GP7 states into ISR (Input Shift Register)
    ; NOTE: we should not have to add a delay for transceiver propagation
    ; here because the RD signal passes through the same type of transceiver too
    ; For stability reasons though (two transceivers will never be *exactly* the same)
    ; we add a small delay anyway
    ;nop [7]                    ; 3*3.698ns delay    
    mov isr, x                  ; restore the base address (gets shifted left 8 by the in below)
    in pins, NUM_BUS_PINS       ; shift pins into ISR
    push                        ; push the value read to the RX FIFO

    ; ------------------------------------
    ; Switch transceivers to data output
    ; wait for OE to propagate (3 ticks delay is enough for SN but not for TSX)
    ;set pindirs, 0b11 [2]   ; GP9, GP10 outputs (bits 0, 1)
    set pins, 0b11         ; ADDR_OE high (1) (inactive), DATA_OE high (1) (active)
    nop [25]                ; 26 cycles delay (26*3.968=103.168ns) for TXS0108E transition
    nop [25]                ; min. 200ns needed for enable
  

    ; write to data bus
    mov osr, ~null              ; switch pindirs to output (1)
    out pindirs,8
   
    pull                        ; pull a 32 bit word from tx fifo into OSR
    out pins, NUM_BUS_PINS      ; write to pins from OSR

    ; ------------------------------------
    ; Wait until GP6 (pin 6) goes high: Z80 has completed it's read
    wait 1 pin RD_PIN           

    mov osr, null               ; revert pindirs to input (0)
    out pindirs,8

    ; Switch transceivers back to addr:active, data: inactive  
    ;set pindirs, 0b11   ; GP9, GP10 outputs (bits 0, 1)
    set pins, 0b00      ; ADDR_OE low (0) active, DATA_OE low (0) inactive

    ; this is probably not needed because the Z80 will need longer than
    ; this before it reaches its next RD cycle
    nop [25]                ; delay 26 cycles (26*3.968=103.168ns) for TXS0108E transition
    nop [25]                ; min. 400ns needed for disable
    nop [25]
    nop [25]


    .wrap


% c-sdk {

// Helper function (for use in C program) to initialize this PIO program
void zproc_program_init(PIO pio, uint sm, uint offset) {

    // Initialize all our pins
    // NOTE: pio_gpio_init(), from the official docs:
    // Note that this is not necessary for a state machine to be able to read the 
    // input value from a GPIO, but only for it to set the output value or output enable.
    for (uint i = 0; i < zproc_NUM_PINS; i++) {
        pio_gpio_init(pio, i);
        gpio_set_pulls(i, false, true); // Enable pull-down, disable pull-up
    }

    // Sets up state machine and wrap target. This function is automatically
    // generated in zproc.pio.h.
    pio_sm_config c = zproc_program_get_default_config(offset);

    // input pins (GP0-GP7) setup
    sm_config_set_in_pins(&c, 0);           // Start at GP0
    sm_config_set_in_pin_count(&c, 8);      // GP0-GP7 (8 pins)

    // output pins setup (overlaps in pins)
    sm_config_set_out_pins(&c, 0, zproc_NUM_BUS_PINS);

    // define "set pins" (pins affected by the "set" operation)
    // two pins starting at ADDR_OE_PIN
    sm_config_set_set_pins(&c, zproc_ADDR_OE_PIN, 2);

    // Set shift direction for ISR & OSR
    sm_config_set_in_shift(&c, false, false, 32);    // ISR left shift, auto push after 8 bits
    sm_config_set_out_shift(&c, false, false, 32);   // OSR left shift, auto pull after 8 bits

    // Configure GP0-GP7 as inputs initially
    // NOTE: replaced with code in the pio asm program
    // pio, sm, basepin, numpins, is_out
    // pio_sm_set_consecutive_pindirs(pio, sm, 0, zproc_NUM_BUS_PINS, false);    // false = 0 = input
    
    // Load configuration and jump to start of the program
    pio_sm_init(pio, sm, offset, &c);
}

%}