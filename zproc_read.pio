
;
; GP0-GP7 are connected to the Z80 address lines A0-A7 (through a transceiver)
; 


; Transceiver Information
; SN74LVC245A used for 5V -> 3.3V down translation
; runs at VCC 3.3V
; Pin propagation time at VCC: max 8.3 ns
; OE Enable at VCC: 11 ns
; OE Disable at VCC: 9.5 ns



; timing at 252MHz
; wait: 1 cycle = 3.968 ns
; in: 1 cycle = 3.968 ns
; push: 1 cycle = 3.968 ns
; wrap: 0 cycles
; Total per loop (without wait blocking): 3Ã—3.968=11.904
; If wait blocks, add the blocking time (in multiples of 3.968 ns based on how many cycles GP6 is low).
; DMA: each transfer needs around 100 ns

    ; ------------------------------------
    ; Note that everything in the loop below absolutely MUST happen within the time
    ; that the Z80 needs before it will request  the next byte
    ; The minimum timespan is 4 Z80 cycles
    ; at 4MHz the Z80 needs 1usec (1000ns) for 4 cycles
    ; while the PIO (at 252MHz) requires 3.968 ns / operation
    ; ==> we can process ~ 252 pio operations during one Z80 cycle
    ; Problem: The TXS0108E needs extremely long for enable/disable
    ; as long as that is in use 200+400=600ns (60% of our budget) 
    ; are required for OE on that transceiver alone


.program zproc_read

.define public NUM_PINS         16  ; both buses
.define public NUM_BUS_PINS     8   ; per bus

.define public BUS_PIN_0        0
.define public ADDR_BUS_PIN_0   0
.define public DATA_BUS_PIN_0   8

.define public DATA_OE_RD   20   ; data bus read transceiver OE
.define public ADDR_OE_LSB  19   ; address bus transceiver OE

.define public RD_PIN      27
.define public WR_PIN      26

; 0bDATA|ADDR (0=on, 1=0ff)
.define ADDR_ON_DATA_WRITE_OFF  0b10
.define ADDR_OFF_DATA_WRITE_OFF 0b11
.define ADDR_OFF_DATA_WRITE_ON  0b01


; This is used to process data to&from the Z80

    ; get the SRAM base address into x
    pull
    mov x, osr

    .wrap_target

    ; ------------------------------------
    ; Wait for GP6 to go low (active)
    wait 0 pin RD_PIN       ; Wait until RD pin is low  

    ; switch bus pins to in (0)
    mov osr, null
    out pindirs, NUM_BUS_PINS

    // set OE control pins 
    set pindirs, 0b11       ; output (bits 0, 1)
    set pins, ADDR_ON_DATA_WRITE_OFF
    nop [22]                ; delay for transceiver OE: 5*3.968 ~= 20 ns


    ; ------------------------------------
    ; Read GP0-GP7 states into ISR (Input Shift Register)
    mov isr, x                  ; restore the base address (gets shifted left 8 by the in below)
    in pins, NUM_BUS_PINS       ; shift address bus pins into ISR
    push                        ; push the value read to the RX FIFO

    ; ------------------------------------
    ; write the byte from SRAM to the Z80 data bus

    // set  OE control pins for data bus write
    set pindirs, 0b11       ; output (bits 0, 1)
    set pins, ADDR_OFF_DATA_WRITE_ON
    nop [22]                ; delay for transceiver OE: 5*3.968 ~= 20 ns

    ;^^^^^^^^^^^^^^^^^^^^^^^^irq 0

    mov osr, ~null              ; switch pindirs to output (1)
    out pindirs,NUM_BUS_PINS
    pull block                  ; pull a 32 bit word from tx fifo into OSR
    

    out pins, NUM_BUS_PINS      ; write to pins from OSR



    ; ------------------------------------
    ; Wait until RD pin goes high again: Z80 has completed it's read cycle
    wait 1 pin RD_PIN           

    .wrap


% c-sdk {

// Helper function (for use in C program) to initialize this PIO program
void zproc_read_program_init(PIO pio, uint sm, uint offset) {

    // Initialize all our pins
    // NOTE: pio_gpio_init(), from the official docs:
    // Note that this is not necessary for a state machine to be able to read the 
    // input value from a GPIO, but only for it to set the output value or output enable.
    for (uint i = zproc_read_BUS_PIN_0; i < zproc_read_BUS_PIN_0+zproc_read_NUM_PINS; i++) {
        pio_gpio_init(pio, i);
        gpio_set_pulls(i, false, false); 
    }

    // Configure RD pin as input
    pio_gpio_init(pio, zproc_read_RD_PIN);
    pio_sm_set_consecutive_pindirs(
        pio, sm, zproc_read_RD_PIN, 1, false);    // false = 0 = input

    // OE pins as output
    pio_gpio_init(pio, zproc_read_ADDR_OE_LSB);
    pio_gpio_init(pio, zproc_read_DATA_OE_RD);
    pio_sm_set_consecutive_pindirs(
        pio, sm, zproc_read_ADDR_OE_LSB, 2, true);    // is_out=true
                                                                                                                                                     
    // Sets up state machine and wrap target. This function is automatically
    // generated in zproc.pio.h.
    pio_sm_config c = zproc_read_program_get_default_config(offset);

    // ADDR+DATA BUS input pins set
    sm_config_set_in_pins(&c, zproc_read_BUS_PIN_0);
    sm_config_set_in_pin_count(&c, zproc_read_NUM_PINS);

    // output pins: DATA BUS 
    //sm_config_set_out_pins(&c, zproc_read_DATA_BUS_PIN_0, zproc_read_NUM_BUS_PINS);

    // define "set pins" (pins affected by the "set" operation)
    // two control pins starting at ADDR_OE_LSB
    sm_config_set_set_pins(&c, zproc_read_ADDR_OE_LSB, 2);

    // Set shift direction for ISR & OSR
    sm_config_set_in_shift(&c, false, false, 32);    // ISR left shift, auto push after 8 bits
    sm_config_set_out_shift(&c, false, false, 32);   // OSR left shift, auto pull after 8 bits
    
    // Load configuration and jump to start of the program
    pio_sm_init(pio, sm, offset, &c);
}

%}