
;
; GP0-GP7 are connected to the Z80 address lines A0-A7 (through a transceiver)
; 


; Transceiver Information
; SN74LVC245A used for 5V -> 3.3V down translation
; runs at VCC 3.3V
; Pin propagation time at VCC: max 8.3 ns
; OE Enable at VCC: 11 ns
; OE Disable at VCC: 9.5 ns

; TXS0108E
; OE Enable: 200 ns
; OE Disable: 400 ns


; timing at 252MHz
; wait: 1 cycle = 3.968 ns
; in: 1 cycle = 3.968 ns
; push: 1 cycle = 3.968 ns
; wrap: 0 cycles
; Total per loop (without wait blocking): 3Ã—3.968=11.904
; If wait blocks, add the blocking time (in multiples of 3.968 ns based on how many cycles GP6 is low).
; DMA: each transfer needs around 100 ns

    ; ------------------------------------
    ; Note that everything in the loop below absolutely MUST happen within the time
    ; that the Z80 needs before it will request  the next byte
    ; The minimum timespan is 4 Z80 cycles
    ; at 4MHz the Z80 needs 1usec (1000ns) for 4 cycles
    ; while the PIO (at 252MHz) requires 3.968 ns / operation
    ; ==> we can process ~ 252 pio operations during one Z80 cycle
    ; Problem: The TXS0108E needs extremely long for enable/disable
    ; as long as that is in use 200+400=600ns (60% of our budget) 
    ; are required for OE on that transceiver alone


.program zproc_read

.define public NUM_BUS_PINS    8    
.define public NUM_PINS        10   

.define public BUS_PIN_0   0
.define public ADDR_OE_PIN 8    ; address transceiver OE
.define public DATA_OE_PIN 9    ; data transceiver OE

.define public RD_PIN      27
.define public WR_PIN      26


; This is used to process data to&from the Z80

    ; get the SRAM base address into x
    pull
    mov x, osr

    .wrap_target

    ; ------------------------------------
    ; Wait for GP6 to go low (active)
    wait 0 pin RD_PIN       ; Wait until RD pin is low  

    // set OE control pins 
    set pindirs, 0b11       ; GP9, GP10 outputs (bits 0, 1)
    set pins, 0b10          ; DATA_OE high (1) (inactive), ADDR_OE low (0) (active), 

    ; switch bus pins to in (0)
    mov osr, null
    out pindirs, NUM_BUS_PINS

    nop [31]
    nop [31]

    ; ------------------------------------
    ; Read GP0-GP7 states into ISR (Input Shift Register)
    mov isr, x                  ; restore the base address (gets shifted left 8 by the in below)
    in pins, NUM_BUS_PINS       ; shift pins into ISR
    push                        ; push the value read to the RX FIFO

    ; ------------------------------------
    ; write the byte from SRAM to the Z80 data bus

    ;mov osr, ~null              ; switch pindirs to output (1)
    ;out pindirs,NUM_BUS_PINS [6]

    ; Switch transceivers to data output (tsx enable -> max. 200 ns)
    ;;set pindirs, 0b11           ; GP9, GP10 outputs (bits 0, 1)
    ;;set pins, 0b10              ; DATA_OE low (0) (active), ADDR_OE high (1) (inactive)

    ;pull block                  ; pull a 32 bit word from tx fifo into OSR
    ;out pins, NUM_BUS_PINS      ; write to pins from OSR

    ; irq 0

    ; ------------------------------------
    ; Wait until RD pin goes high again: Z80 has completed it's read cycle
    wait 1 pin RD_PIN           

    ; Switch transceivers to data output (tsx enable -> max. 200 ns)
    ;set pindirs, 0b11           ; GP9, GP10 outputs (bits 0, 1)
    ;set pins, 0b01              ; DATA_OE low (0) (active), ADDR_OE high (1) (inactive)

    .wrap


% c-sdk {

// Helper function (for use in C program) to initialize this PIO program
void zproc_read_program_init(PIO pio, uint sm, uint offset) {

    // Initialize all our pins
    // NOTE: pio_gpio_init(), from the official docs:
    // Note that this is not necessary for a state machine to be able to read the 
    // input value from a GPIO, but only for it to set the output value or output enable.
    for (uint i = zproc_read_BUS_PIN_0; i < zproc_read_BUS_PIN_0+zproc_read_NUM_PINS; i++) {
        pio_gpio_init(pio, i);
        gpio_set_pulls(i, false, false); 
    }

    // Configure RD pin as input
    pio_gpio_init(pio, zproc_read_RD_PIN);
    pio_sm_set_consecutive_pindirs(pio, sm, zproc_read_RD_PIN, 1, false);    // false = 0 = input
                                                                                                                                                     
    // Sets up state machine and wrap target. This function is automatically
    // generated in zproc.pio.h.
    pio_sm_config c = zproc_read_program_get_default_config(offset);

    // BUS input pins setup
    sm_config_set_in_pins(&c, zproc_read_BUS_PIN_0);
    sm_config_set_in_pin_count(&c, zproc_read_NUM_BUS_PINS);

    // output pins: BUS (overlaps in pins)
    // NOTE: if the  OE control pins are set as out pins here
    // they get included in the "out set" and every out operation
    // will affect them too! Better control them using the "set set"
    sm_config_set_out_pins(&c, zproc_read_BUS_PIN_0, zproc_read_NUM_BUS_PINS);

    // define "set pins" (pins affected by the "set" operation)
    // two control pins starting at ADDR_OE_PIN
    sm_config_set_set_pins(&c, zproc_read_ADDR_OE_PIN, 2);

    // Set shift direction for ISR & OSR
    sm_config_set_in_shift(&c, false, false, 32);    // ISR left shift, auto push after 8 bits
    sm_config_set_out_shift(&c, false, false, 32);   // OSR left shift, auto pull after 8 bits
    
    // Load configuration and jump to start of the program
    pio_sm_init(pio, sm, offset, &c);
}

%}